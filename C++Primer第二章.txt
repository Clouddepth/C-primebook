ba第二章：

2.1 基本内置类型
C++定义了一套包括算术类型和空类型在内的基本数据类型
算术类型包含了字符、整形数、布尔值和浮点数。
空类型不对应具体的值，仅用于一些特殊的场合

2.1.1 算术类型
分为两类：整形（包括字符和布尔类型在内）和浮点型

尺寸：
bool 布尔类型 最小尺寸未定义
char 字符 最小尺寸8位
wchar_t 宽字符 最小尺寸16位
char16_t Unicode字符 最小尺寸16位
char32_t Unicode字符 最小尺寸32位
short 短整型 最小尺寸16位
int 整型 最小尺寸16位
long 长整型 最小尺寸32位
long long 长整型 最小尺寸64位
float 单精度浮点数 6位有效数字
double 双精度浮点数 10位有效数字
long double 扩展精度浮点数 10位有效数字 

一个int至少和一个short一样大 一个long至少和一个int一样大 一个long long至少和一个long一样大

在int short long 和long long都是带符号的，在前面加unsigned就可以得到无符号类型，例如unsigned long，unsigned int可以缩写成unsigned

2.1.3 字面值常量
转义序列：
两类字符不能直接使用：1、不可打印的字符 2、含有特殊含义的字符
这些清空下需要用到转义序列
换行符： \n     横向制表符： \t     报警（响铃）符：  \a     纵向制表符：  \v    退格符：  \b    双引号：  \"
反斜线：  \\   问号：  \?   单引号：  \'   回车符：  \r  进纸符： \f


2.2 变量
2.2.1 变量定义
变量定义的基本形式是：首先是类型说明符，随后紧跟一个或者多个变量名组成的列表 变量名用逗号分隔，分号结束

初始值：
当对象在创建的时候获得了一个特定的值，就说这个对象被初始化了。
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而用一个新值来替代

2.2.2 变量声明和定义的关系
c++支持分离式编译机制

声明和定义区分开来。如果想声明一个变量而非定义 需要添加关键字extern
例如：
extern int i；//声明而非定义
int i； //声明并且定义


2.2.4 名字的作用域
作用域能彼此包含，被包含（或者说被嵌套）的作用域称为内层作用域
包含着别的作用域的作用域被称为外层作用域


2.3复合类型
复合类型是指基于其他类型定义的类型
一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成
每个声明符命名了一个变量并指定该变量为基本数据类型有关的某种类型

2.3.1 引用
引用为对象起了一个别名
引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字
引用类型的初始值必须是一个对象

2.3.2 指针
指针是指向另外一种类型的复合类型
指针存放某个对象的地址，获取地址需要使用取地址符（&）

指针的值（即地址）应属于下列4中状态之一：
1、指向一个对象
2、指向紧邻对象所占空间的下一个位置
3、空指针，意味着指针没有指向任何一个对象
4、无效指针，也就是上述情况之外的其他值

如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象
解引用操作仅适用于那些确定指向了某个对象的有效指针

空指针：
空指针不指向任何对象
生成方法：
int *p1 = nullptr；
int *p2 = 0;
int *pe = NULL;

对于两个类型相同的合法指针，可以用（==）或者（！=）来比较，结果是布尔类型
这里两个指针存放的地址值相同（两个指针相等）有三种可能：
1、他们都为空
2、都指向同一个对象
3、都指向了同一个对象的下一个地址
需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一个地址，此时也有可能出现这两个指针的值相同的情况，即指针相等


void* 指针：
void* 是一种特殊的指针类型，可用于存放任意对象的地址，一个void*指针存放着一个地址，不同的是我们对这个地址中到底是个什么类型的对象并不了解
不能直接操作void*指针所指的对象 


指向指针的引用：
引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用
int i = 42； int *p; int *&r = p;  r = &i;  *r = 0;


2.4 const限定符
const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

2.4.1 const的引用
把引用绑定到const对象上，称之为对常量的引用，对常量的引用不能被用作修改它所绑定的对象

2.4.3 顶层const
用名词顶层const表示指针本身是个常量，用名词底层const表示指针所指的对象是一个常量
用于声明引用的const都是底层const

2.4.4 常量表达式和constexpr
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式

允许将变量声明为constexper类型以便由编译器来验证变量的值是否是一个常量表达式
一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型

2.5 处理类型

2.5.1 类型别名
第一种方式，使用关键字typedef 
typedef double wages；//wages是double的同义词
wages hourly;等价于double hourly;
第二章方式，使用别名声明
using SI = Sales_item;等价于Sales_item item;

 
2.5.2 auto类型说明符
使用auto类型说明符，编译器能自动分析表达式所属的数据类型
auto定义的变量必须有初始值
auto item = val1+val2; 根据val1加val2的结果推断item的类型

如果希望推断出的auto类型是一个顶层const，需要明确的指出
还可以将引用的类型设为auto，此时原来的初始化规则仍然适用

2.5.3 decltype类型指示符
作用是选择并返回操作数的数据类型
decltype（f（）） sum = x； //sum的类型就是函数f的返回类型
如果decltype使用的表达式是一个变量，则decltype返回该变量的类型
const int ci = 0；&cj = ci;
decltype( ci) x = 0;//x的类型就是const int
decltype(cj) y= 0; //y的类型就是const int&

int i = 42;
decltype((i)) d;//错误，d是int& 必须初始化
decltype（（variablke））的结果永远是引用，而decltype(variablke)的结果只有当variablke本身是引用时才是引用

头文件保护符可以有效的防止重复包含的发生
预处理变量无视c++中关于作用域的规则





















